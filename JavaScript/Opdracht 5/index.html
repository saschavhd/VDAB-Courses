<!DOCTYPE html>
<!-- saved from url=(0117)https://leren.vdab.be/pluginfile.php/4999/mod_scorm/imsmanifest/2/43281/objects/il_0_file_53360/JS_taak_TagCloud.html -->
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<title>JS PF taak: TagCloud</title>
	<style media="screen" type="text/css">
		em {
			font-style:normal;
			font-weight:bold;
			color:#906;
		}
		img {
			float:left
		}
		h3 {
			clear:both;
		}
		#tagContainer {
			position:relative;
			background-color:#CFF;
			margin:1em;
			padding:0;
			width: 500px;
			height: 400px;
			overflow:hidden;
			border:2px solid silver;
		}
		span {
			display: inline-block;
		}
	</style>
</head>
<body>
	<h1>Javascript PF taak: eenvoudige Tag cloud</h1>
	<p><img src="img/350px-World_Population.png" alt="wereldbevolking per land">Een <em>tag cloud</em> of <em>data cloud</em>,    is een visuele voorstelling van het belang van een term, meestal in een website. <br>
	    Het aantal keren dat die term voorkomt wordt dan voorgesteld door de lettergrootte en/of de kleur van het woord. Hiernaast zie je bijvoorbeeld een tag cloud die het aantal inwoners per land weergeeft</p>
	<h3>Opdracht: </h3>
	<ul>
	    <li>Bekijk de broncode. Dit bestand bevat een Array <code>arrTags</code> . Maak er gebruik van om een eenvoudige <em>tag cloud</em> te produceren in het element <code>#tagContainer</code></li>
	    <li>maak voor elke term in het array een <code>span</code> element aan en positioneer dat <code>absolute</code> in de container.</li>
	    <li>Maak gebruik van <code>Math.random()</code> om een willekeurige plaats, zowel vertikaal als horizontaal, te genereren binnen de container.</li>
	    <li>bedenk zelf een algoritme die de lettergrootte berekend afhankelijk van het aantal stemmen die een term kreeg</li>
	    <li>kan je ook de kleur toekennen? groen voor stijgers, rood voor dalers</li>
	</ul>
	<h3>Geteste topics</h3>
	<ul>
	    <li>Arrays</li>
	    <li>style properties</li>
	    <li><code>Math.random()</code> object</li>
	</ul>
	<div id="tagContainer"></div>
<script type="text/javascript">
	// Notes:
	//	- Documentation is lazy
	//	- Does not deal with overlapping
	
	// INIT
	const fsMin = 8;
	const fsMax = 42;
	const fsDelta = fsMax - fsMin;
	const arrTags = [
		["Javascript", 1634, 987],
		["jQuery", 1111, 34],
		["PHP", 1024, 1122],
		["Asp.Net", 977, 1005],
		["Photoshop", 594, 789],
		["XML", 40, 666],
		["Access", 55, 77],
		["Java", 278, 277],
		["MySQL", 155, 122]
	];
	let max = 0;
	let min = 10000;
	for (let i = 0; i < arrTags.length; i++) {
		if (arrTags[i][1] > max) {
			max = arrTags[i][1];
		}
		else if (arrTags[i][1] < min) {
			min = arrTags[i][1];
		}
	}
	const difference = max - min;

	// DOM INIT
	const container = document.getElementById('tagContainer');
	const cHeight = container.offsetHeight;
	const cWidth = container.offsetWidth;

	// NEW NODE
	function newNode(arr) {
		// Unpacking values
		this.name = arr[0];
		this.now = arr[1];
		this.prev = arr[2];

		// Determine color based on value difference
		if (this.now - this.prev > 0) {this.color = 'green';}
		else if (this.now - this.prev < 0) {this.color = 'red';}
		else {this.color = 'black';}

		// Calculate font size
		this.size = Math.floor(fsMin + ((this.now/difference) * fsDelta));

		// Make random coordinate that will fit with font size
		this.x = Math.floor(Math.random() * (cHeight - this.size));
		this.y = Math.floor(Math.random() * (cWidth - (this.size * this.name.length)));

		// Create element
		this.node = document.createElement('span');
		// Set appropriate values
		node.innerHTML = this.name;
		node.style.position = 'absolute';
		node.style.fontSize = this.size + "px";
		node.style.top = this.x + "px";
		node.style.left = this.y + "px";
		node.style.color = this.color;
		// Add element to container
		container.appendChild(this.node);
	}

	// MAIN LOOP
	for (let i = 0; i < arrTags.length; i++) {
		newNode(arrTags[i]);
	}
</script>
</body>
</html>
